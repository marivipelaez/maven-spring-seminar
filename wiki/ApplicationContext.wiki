#sidebar TOC
<wiki:toc max_depth="4" />

= Introducción =

El fichero de configuración básico de Spring es el contexto de aplicación (application context). Consiste en un fichero XML donde se añadirán todos los objectos que deberán existir en la aplicación al inicializarse la misma. 

= Levantar el contexto de Spring = 
== En una aplicación web ==
En el caso de una aplicación web, el contexto lo levanta el contenedor de servlets y, al configurar el servlet correspondiente a Spring en el web.xml, se indicará el applicationContext.xml:
{{{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd">
<web-app>
.....
<!-- Spring framework context file -->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/applicationContext.xml</param-value>
</context-param>

<!-- Spring framework context loader listener -->
<listener>
   <listener-class>
	org.springframework.web.context.ContextLoaderListener
   </listener-class>
</listener>
....
</web-app>
}}}

== En una aplicación standalone ==
En el main se añadirá:
{{{
public static void main(String[] args) throws Exception {
....
final static String CONTEXT = "applicationContext.xml";
String[] contextPaths = new String[] { CONTEXT };
AbstractApplicationContext ctx = new ClassPathXmlApplicationContext(
		contextPaths);
....
}
}}}

= Configurar el contexto de Spring =
Se debe generar un descriptor de contexto para cada módulo del proyecto. El mínimo será:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans 
	xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" 
	default-autowire="byName">
	
	
    <bean id="..." class="...">
        ...
    </bean>
    .....
	
    <bean id="..." class="...">
        ...
    </bean>
</beans>
}}}

Pero existirá un único applicationContext por aplicación. Para esto los contextos se agrupan, importándose:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans default-autowire="byName"
	xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<!-- Include the configuration files of the other components -->
	<import
		resource="classpath*:dbaccessContext.xml" />
        <import
		resource="classpath*:servicesContext.xml" />
....
</beans>

}}}

= Inyección de dependencias =

Una vez declarado un bean en un contexto, puede referenciarse desde cualquier punto de la aplicación. Esto significa dos cosas:
  # En un proyecto con varios applicationContext, los objectos son accesibles desde cualquiera de los ficheros xml:
{{{
Editando el services.xml....
<?xml version="1.0" encoding="UTF-8"?>
<beans default-autowire="byName"
	xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

<!-- En el dbaccessContext.xml se han definido los daos -->
<!-- Include the configuration files of the other components -->
	<import
		resource="classpath*:dbaccessContext.xml" />
......
       <bean id="userService" class="es.tid.ad.seminar.ms.services.impl.UserService">
           <property name="userDao" ref="userDao" />
       </bean>
......
</beans>
}}}

  # Los objectos se pueden inyectar en cualquier clase uitlizando las anotaciones correspondientes:
{{{
......
@ContextConfiguration(locations = { "classpath*:**testContext.xml" })
@RunWith(SpringJUnit4ClassRunner.class)
public class UserDaoTest {

    final static Log LOG = LogFactory.getLog(UserDaoTest.class);

    @Autowired(required = true)
    private UserDao userDao;

......

 public void setUserDao(UserDao userDao) {
	this.userDao = userDao;
    }
}
}}}

En cualquiera de los dos casos, "la inyección" se realiza através del método setter de la propiedad, por lo que es obligatorio crearlo.

= Helpers =
== Importar ficheros de propiedades ==
Normalmente algunas de las propiedades que se asignen a los beans declarados en un application context, tomarán su valor de los ficheros de propiedades de la aplicación. La forma de cargarlos es:
{{{
<!-- Use the property configurer for assigning configuration variables -->
<bean id="propertyConfigurer"
	class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	<property name="locations" value="classpath*:main.properties"/>
</bean>
}}}
Y la forma de acceder a las propiedades es:
{{{
<!-- Database Connection Parameters -->

<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${db.driver}" />
		<property name="url" value="${db.url}" />
		<property name="username" value="${db.username}" />
		<property name="password" value="${db.password}" />
</bean>
}}}
== Acceder a recursos de mensajes ==
Spring permite definir ficheros de mensajes. Estos recursos de mensajes podrán ser multiidioma, que se podrá elegir dependiendo del idioma del servidor, de la request, etc.
La forma de definirlos es:
{{{
<!-- Configure the message source for info messages and errors -->
<bean id="messageSource"
	class="org.springframework.context.support.ResourceBundleMessageSource">
	<property name="basenames">
		<list>
			<value>services</value>
			<value>validators</value>
		</list>
	</property>
</bean>
}}}
Y la de recuperar un mensaje:
{{{
applicationContext
	    .getMessage("empty.avatar.uuid", params, Locale.getDefault())
}}}